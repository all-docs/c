<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><head>
<title>Array declaration</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="alternate" type="application/x-wiki" title="Edit" href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit">
<link rel="edit" title="Edit" href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit">
<link rel="shortcut icon" href="../../../favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="../../../mwiki/opensearch_desc.php" title="cppreference.com (en)">
<link rel="EditURI" type="application/rsd+xml" href="../../../mwiki/api.php@action=rsd">
<link rel="alternate" type="application/atom+xml" title="cppreference.com Atom feed" href="https://en.cppreference.com/mwiki/index.php?title=Special:RecentChanges&amp;feed=atom">

<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #0000dd;}
.c.source-c .kw2 {color: #0000ff;}
.c.source-c .kw3 {color: #0000dd;}
.c.source-c .kw4 {color: #0000ff;}
.c.source-c .co1 {color: #909090;}
.c.source-c .co2 {color: #339900;}
.c.source-c .coMULTI {color: #ff0000; font-style: italic;}
.c.source-c .es0 {color: #008000; font-weight: bold;}
.c.source-c .es1 {color: #008000; font-weight: bold;}
.c.source-c .es2 {color: #008000; font-weight: bold;}
.c.source-c .es3 {color: #008000; font-weight: bold;}
.c.source-c .es4 {color: #008000; font-weight: bold;}
.c.source-c .es5 {color: #008000; font-weight: bold;}
.c.source-c .br0 {color: #008000;}
.c.source-c .sy0 {color: #008000;}
.c.source-c .sy1 {color: #000080;}
.c.source-c .sy2 {color: #000040;}
.c.source-c .sy3 {color: #000040;}
.c.source-c .sy4 {color: #008080;}
.c.source-c .st0 {color: #008000;}
.c.source-c .nu0 {color: #000080;}
.c.source-c .nu6 {color:#000080;}
.c.source-c .nu8 {color:#000080;}
.c.source-c .nu12 {color:#000080;}
.c.source-c .nu16 {color:#000080;}
.c.source-c .nu17 {color:#000080;}
.c.source-c .nu18 {color:#000080;}
.c.source-c .nu19 {color:#000080;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-c_language_array skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->




                <h1 id="firstHeading" class="firstHeading">Array declaration</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>Array is a type consisting of a contiguously allocated nonempty sequence of objects with a
particular <i>element type</i>. The number of those objects (the array size) never changes during the array lifetime.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="./array.htm#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="./array.htm#Explanation"><span class="tocnumber">2</span> <span class="toctext">Explanation</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="./array.htm#Arrays_of_constant_known_size"><span class="tocnumber">2.1</span> <span class="toctext">Arrays of constant known size</span></a></li>
<li class="toclevel-2"><a href="./array.htm#Variable-length_arrays"><span class="tocnumber">2.2</span> <span class="toctext">Variable-length arrays</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="./array.htm#Arrays_of_unknown_size"><span class="tocnumber">2.3</span> <span class="toctext">Arrays of unknown size</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="./array.htm#Qualifiers"><span class="tocnumber">2.4</span> <span class="toctext">Qualifiers</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="./array.htm#Assignment"><span class="tocnumber">2.5</span> <span class="toctext">Assignment</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="./array.htm#Array_to_pointer_conversion"><span class="tocnumber">2.6</span> <span class="toctext">Array to pointer conversion</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="./array.htm#Multidimensional_arrays"><span class="tocnumber">2.7</span> <span class="toctext">Multidimensional arrays</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="./array.htm#Notes"><span class="tocnumber">3</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="./array.htm#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="./array.htm#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=1" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span></h3>
<p>In the <a href="./declarations.htm" title="c/language/declarations">declaration grammar</a> of an array declaration, the <i>type-specifier</i> sequence designates the <i>element type</i> (which must be a complete object type), and the <i>declarator</i> has the form:
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>[</b></code> <code><b>static</b></code><span class="t-mark">(optional)</span> <span class="t-spar">qualifiers</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">expression</span> ﻿<span class="t-mark">(optional)</span> <code><b>]</b></code> <span class="t-spar">attr-spec-seq</span> ﻿<span class="t-mark">(optional)</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>[</b></code> <span class="t-spar">qualifiers</span> ﻿<span class="t-mark">(optional)</span> <code><b>static</b></code><span class="t-mark">(optional)</span> <span class="t-spar">expression</span> ﻿<span class="t-mark">(optional)</span> <code><b>]</b></code> <span class="t-spar">attr-spec-seq</span> ﻿<span class="t-mark">(optional)</span>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>[</b></code> <span class="t-spar">qualifiers</span> ﻿<span class="t-mark">(optional)</span> <code><b>*</b></code> <code><b>]</b></code> <span class="t-spar">attr-spec-seq</span> ﻿<span class="t-mark">(optional)</span>
</td>
<td> (3)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<div class="t-li1"><span class="t-li">1,2)</span> General array declarator syntax</div>
<div class="t-li1"><span class="t-li">3)</span> Declarator for VLA of unspecified size (can appear in function prototype scope only)
where</div>
<table class="t-par-begin">


<tbody><tr class="t-par">
<td> <span class="t-spar">expression</span>
</td>
<td> -
</td>
<td> any expression other than <a href="./operator_other.htm#Comma_operator" title="c/language/operator other">comma operator</a>, designates the number of elements in the array
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">qualifiers</span>
</td>
<td> -
</td>
<td> any combination of <a href="./const.htm" title="c/language/const"><code>const</code></a>, <a href="./restrict.htm" title="c/language/restrict"><code>restrict</code></a>, or <a href="./volatile.htm" title="c/language/volatile"><code>volatile</code></a> qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">attr-spec-seq</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-c23">(C23)</span>optional list of <a href="./attributes.htm" title="c/language/attributes">attributes</a>, applied to the declared array
</td></tr></tbody></table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">float</span> fa<span class="br0">[</span><span class="nu0">11</span><span class="br0">]</span>, <span class="sy2">*</span>afp<span class="br0">[</span><span class="nu0">17</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// fa is an array of 11 floats</span>
                        <span class="co1">// afp is an array of 17 pointers to floats</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=2" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span></h3>
<p>There are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.
</p>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=3" title="Edit section: Arrays of constant known size">edit</a>]</span> <span class="mw-headline" id="Arrays_of_constant_known_size">Arrays of constant known size</span></h4>
<p>If <span class="t-spar">expression</span> in an array declarator is an <a href="./constant_expression.htm#Integer_constant_expression" title="c/language/constant expression">integer constant expression</a> with a value greater than zero <span class="t-rev-inl t-since-c99"><span>and the element type is a type with a known constant size (that is, elements are not VLA)</span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span>, then the declarator declares an array of constant known size:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// integer constants are constant expressions</span>
<span class="kw4">char</span> o<span class="br0">[</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// sizeof is a constant expression</span>
<span class="kw2">enum</span> <span class="br0">{</span> MAX_SZ<span class="sy1">=</span><span class="nu0">100</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> n<span class="br0">[</span>MAX_SZ<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// enum constants are constant expressions</span></pre></div></div>
<p>Arrays of constant known size can use <a href="./array_initialization.htm" title="c/language/array initialization">array initializers</a> to provide their initial values:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// declares int[5] initialized to 1,2,3,0,0</span>
<span class="kw4">char</span> str<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="st0">"abc"</span><span class="sy4">;</span> <span class="co1">// declares char[4] initialized to 'a','b','c','\0'</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-c99"><td>
<p>In function parameter lists, additional syntax elements are allowed within the array declarators: the keyword <code><b>static</b></code> and <span class="t-spar">qualifiers</span>, which may appear in any order before the size expression (they may also appear even when the size expression is omitted).
</p><p>In each <a href="./operator_other.htm#Function_call" title="c/language/operator other">function call</a> to a function where an array parameter uses the keyword <code><b>static</b></code> between <code><b>[</b></code> and <code><b>]</b></code>, the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by <span class="t-spar">expression</span>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">void</span> fadd<span class="br0">(</span><span class="kw4">double</span> a<span class="br0">[</span><span class="kw4">static</span> <span class="nu0">10</span><span class="br0">]</span>, <span class="kw4">const</span> <span class="kw4">double</span> b<span class="br0">[</span><span class="kw4">static</span> <span class="nu0">10</span><span class="br0">]</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> i<span class="sy2">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">&lt;</span> <span class="nu16">0.0</span><span class="br0">)</span> <span class="kw1">return</span><span class="sy4">;</span>
        a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">+</span><span class="sy1">=</span> b<span class="br0">[</span>i<span class="br0">]</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
<span class="co1">// a call to fadd may perform compile-time bounds checking</span>
<span class="co1">// and also permits optimizations such as prefetching 10 doubles</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">double</span> a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span>, b<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
    fadd<span class="br0">(</span>a, b<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
    <span class="kw4">double</span> x<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
    fadd<span class="br0">(</span>x, b<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// undefined behavior: array argument is too small</span>
<span class="br0">}</span></pre></div></div>
<p>If <span class="t-spar">qualifiers</span> are present, they qualify the pointer type to which the array parameter type is transformed:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// in this function, a has type const int* (pointer to const int)</span>
<span class="br0">}</span>
<span class="kw4">int</span> g<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span> a<span class="br0">[</span><span class="kw4">const</span> <span class="nu0">20</span><span class="br0">]</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// in this function, a has type const int* const (const pointer to const int)</span>
<span class="br0">}</span></pre></div></div>
<p>This is commonly used with the <a href="./restrict.htm" title="c/language/restrict"><code>restrict</code></a> type qualifier:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">void</span> fadd<span class="br0">(</span><span class="kw4">double</span> a<span class="br0">[</span><span class="kw4">static</span> <span class="kw4">restrict</span> <span class="nu0">10</span><span class="br0">]</span>,
          <span class="kw4">const</span> <span class="kw4">double</span> b<span class="br0">[</span><span class="kw4">static</span> <span class="kw4">restrict</span> <span class="nu0">10</span><span class="br0">]</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> i<span class="sy2">++</span><span class="br0">)</span> <span class="co1">// loop can be unrolled and reordered</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy1">&lt;</span> <span class="nu16">0.0</span><span class="br0">)</span>
            <span class="kw1">break</span><span class="sy4">;</span>
        a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy2">+</span><span class="sy1">=</span> b<span class="br0">[</span>i<span class="br0">]</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<h4> <span class="mw-headline" id="Variable-length_arrays">Variable-length arrays</span></h4>
<p>If <span class="t-spar">expression</span> is not an <a href="./constant_expression.htm#Integer_constant_expression" title="c/language/constant expression">integer constant expression</a>, the declarator is for an array of variable size.
</p><p>Each time the flow of control passes over the declaration, <span class="t-spar">expression</span> is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, <a href="./lifetime.htm" title="c/language/lifetime">lifetime</a> of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
   <span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
label<span class="sy4">:;</span>
   <span class="kw4">int</span> a<span class="br0">[</span>n<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// re-allocated 10 times, each with a different size</span>
   <a href="../io/fprintf.htm"><span class="kw851">printf</span></a><span class="br0">(</span><span class="st0">"The array has&nbsp;%zu elements<span class="es1">\n</span>"</span>, <span class="kw4">sizeof</span> a <span class="sy2">/</span> <span class="kw4">sizeof</span> <span class="sy2">*</span>a<span class="br0">)</span><span class="sy4">;</span>
   <span class="kw1">if</span> <span class="br0">(</span>n<span class="sy2">++</span> <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="br0">)</span>
       <span class="kw1">goto</span> label<span class="sy4">;</span> <span class="co1">// leaving the scope of a VLA ends its lifetime</span>
<span class="br0">}</span></pre></div></div>
</div>
<p>If the size is <code><b>*</b></code>, the declaration is for a VLA of unspecified size. Such declaration may only appear in a function prototype scope, and declares an array of a complete type. In fact, all VLA declarators in function prototype scope are treated as if <span class="t-spar">expression</span> were replaced by <code><b>*</b></code>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">void</span> foo<span class="br0">(</span><a href="../types/size_t.htm"><span class="kw100">size_t</span></a> x, <span class="kw4">int</span> a<span class="br0">[</span><span class="sy2">*</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> foo<span class="br0">(</span><a href="../types/size_t.htm"><span class="kw100">size_t</span></a> x, <span class="kw4">int</span> a<span class="br0">[</span>x<span class="br0">]</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../io/fprintf.htm"><span class="kw851">printf</span></a><span class="br0">(</span><span class="st0">"%zu<span class="es1">\n</span>"</span>, <span class="kw4">sizeof</span> a<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// same as sizeof(int*)</span>
<span class="br0">}</span></pre></div></div>
<p>Variable-length arrays and the types derived from them (pointers to them, etc) are commonly known as "variably-modified types" (VM). Objects of any variably-modified type may only be declared at block scope or function prototype scope.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw2">extern</span> <span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw4">int</span> A<span class="br0">[</span>n<span class="br0">]</span><span class="sy4">;</span>            <span class="co1">// Error: file scope VLA</span>
<span class="kw2">extern</span> <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p2<span class="br0">)</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// Error: file scope VM</span>
<span class="kw4">int</span> B<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span><span class="sy4">;</span>          <span class="co1">// OK: file-scope array of constant known size</span>
<span class="kw4">void</span> fvla<span class="br0">(</span><span class="kw4">int</span> m, <span class="kw4">int</span> C<span class="br0">[</span>m<span class="br0">]</span><span class="br0">[</span>m<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: prototype-scope VLA</span></pre></div></div>
<p>VLA must have automatic or allocated storage duration. Pointers to VLA, but not VLA themselves may also have static storage duration. No VM type may have linkage.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">void</span> fvla<span class="br0">(</span><span class="kw4">int</span> m, <span class="kw4">int</span> C<span class="br0">[</span>m<span class="br0">]</span><span class="br0">[</span>m<span class="br0">]</span><span class="br0">)</span> <span class="co1">// OK: block scope/auto duration pointer to VLA</span>
<span class="br0">{</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> VLA<span class="br0">[</span>m<span class="br0">]</span><span class="br0">[</span>m<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// OK: block scope VLA</span>
    <span class="kw4">int</span> D<span class="br0">[</span>m<span class="br0">]</span><span class="sy4">;</span>              <span class="co1">// OK: block scope/auto duration VLA</span>
<span class="co1">//  static int E[m]; // Error: static duration VLA</span>
<span class="co1">//  extern int F[m]; // Error: VLA with linkage</span>
    <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>s<span class="br0">)</span><span class="br0">[</span>m<span class="br0">]</span><span class="sy4">;</span>     <span class="co1">// OK: block scope/auto duration VM</span>
    s <span class="sy1">=</span> <a href="../memory/malloc.htm"><span class="kw403">malloc</span></a><span class="br0">(</span>m <span class="sy2">*</span> <span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: s points to VLA in allocated storage</span>
<span class="co1">//  extern int (*r)[m]; // Error: VM with linkage</span>
    <span class="kw4">static</span> <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>q<span class="br0">)</span><span class="br0">[</span>m<span class="br0">]</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>B<span class="sy4">;</span> <span class="co1">// OK: block scope/static duration VM}</span>
<span class="br0">}</span></pre></div></div>
<p>Variably-modified types cannot be members of structs or unions.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw1">struct</span> tag
<span class="br0">{</span>
    <span class="kw4">int</span> z<span class="br0">[</span>n<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// Error: VLA struct member</span>
    <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>y<span class="br0">)</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// Error: VM struct member</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-c99">(since C99)</span></td></tr>
<tr class="t-rev t-since-c11 t-until-c23"><td>
<p>If the compiler defines the macro constant <span class="t-c"><span class="mw-geshi c source-c">__STDC_NO_VLA__</span></span> to integer constant <span class="t-c"><span class="mw-geshi c source-c"><span class="nu0">1</span></span></span>, then VLA and VM types are not supported.
</p>
</td>
<td><span class="t-mark-rev t-since-c11">(since C11)</span><br><span class="t-mark-rev t-until-c23">(until C23)</span></td></tr>
<tr class="t-rev t-since-c23"><td>
<p>If the compiler defines the macro constant <span class="t-c"><span class="mw-geshi c source-c">__STDC_NO_VLA__</span></span> to integer constant <span class="t-c"><span class="mw-geshi c source-c"><span class="nu0">1</span></span></span>, then VLA objects with automatic storage duration are not supported.
</p><p>The support for VM types and VLAs with allocated storage durations is mandated.
</p>
</td>
<td><span class="t-mark-rev t-since-c23">(since C23)</span></td></tr>
</tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=5" title="Edit section: Arrays of unknown size">edit</a>]</span> <span class="mw-headline" id="Arrays_of_unknown_size">Arrays of unknown size</span></h4>
<p>If <span class="t-spar">expression</span> in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an  <a href="./array_initialization.htm" title="c/language/array initialization">initializer</a> is available, such type is an <a href="./compatible_type.htm#Incomplete_types" title="c/language/type">incomplete type</a><span class="t-rev-inl t-since-c99"><span> (note that VLA of unspecified size, declared with <code><b>*</b></code> as the size, is a complete type)</span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw2">extern</span> <span class="kw4">int</span> x<span class="br0">[</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// the type of x is "array of unknown bound of int"</span>
<span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// the type of a is "array of 3 int"</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-c99"><td>
<p>Within a <a href="./struct.htm" title="c/language/struct">struct</a> definition, an array of unknown size may appear as the last member (as long as there is at least one other named member), in which case it is a special case known as <i>flexible array member</i>. See <a href="./struct.htm" title="c/language/struct">struct</a> for details:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw1">struct</span> s <span class="br0">{</span> <span class="kw4">int</span> n<span class="sy4">;</span> <span class="kw4">double</span> d<span class="br0">[</span><span class="br0">]</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// s.d is a flexible array member</span>
<span class="kw1">struct</span> s <span class="sy2">*</span>s1 <span class="sy1">=</span> <a href="../memory/malloc.htm"><span class="kw403">malloc</span></a><span class="br0">(</span><span class="kw4">sizeof</span> <span class="br0">(</span><span class="kw1">struct</span> s<span class="br0">)</span> <span class="sy2">+</span> <span class="br0">(</span><span class="kw4">sizeof</span> <span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span> <span class="sy2">*</span> <span class="nu0">8</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// as if d was double d[8]</span></pre></div></div>
<p><br>
</p>
</td>
<td><span class="t-mark-rev t-since-c99">(since C99)</span></td></tr>
</tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=6" title="Edit section: Qualifiers">edit</a>]</span> <span class="mw-headline" id="Qualifiers">Qualifiers</span></h4>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-c23"><td>
<p>If an array type is declared with a <a href="./const.htm" title="c/language/const"><code>const</code></a>, <a href="./volatile.htm" title="c/language/volatile"><code>volatile</code></a><span class="t-rev-inl t-since-c99"><span>, or <a href="./restrict.htm" title="c/language/restrict"><code>restrict</code></a></span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> qualifier (which is possible through the use of <a href="./typedef.htm" title="c/language/typedef">typedef</a>), the array type is not qualified, but its element type is:
</p>
</td>
<td><span class="t-mark-rev t-until-c23">(until C23)</span></td></tr>
<tr class="t-rev t-since-c23"><td>
<p>An array type and its element type are always considered to be identically qualified, except that an array type is never considered to be <a href="./atomic.htm" title="c/language/atomic"><code>_Atomic</code></a>-qualified.
</p>
</td>
<td><span class="t-mark-rev t-since-c23">(since C23)</span></td></tr>
</tbody></table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw1">typedef</span> <span class="kw4">int</span> A<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">const</span> A a <span class="sy1">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span>, <span class="br0">{</span><span class="nu0">7</span>, <span class="nu0">8</span>, <span class="nu0">9</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// array of array of const int</span>
<span class="kw4">int</span><span class="sy2">*</span> pi <span class="sy1">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// Error: a[0] has type const int*</span>
<span class="kw4">void</span><span class="sy2">*</span> unqual_ptr <span class="sy1">=</span> a<span class="sy4">;</span> <span class="co1">// OK until C23; error since C23</span>
<span class="co1">// Notes: clang applies the rule in C++/C23 even in C89-C17 modes</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-c11"><td>
<p><a href="./atomic.htm" title="c/language/atomic"><code>_Atomic</code></a> is not allowed to be applied to an array type, although an array of atomic type is allowed.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw1">typedef</span> <span class="kw4">int</span> A<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy4">;</span>
<span class="co1">// _Atomic A a0 = {0};    // Error</span>
<span class="co1">// _Atomic(A) a1 = {0};   // Error</span>
_Atomic <span class="kw4">int</span> a2<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// OK</span>
_Atomic<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> a3<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// OK</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-c11">(since C11)</span></td></tr>
</tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=7" title="Edit section: Assignment">edit</a>]</span> <span class="mw-headline" id="Assignment">Assignment</span></h4>
<p>Objects of array type are not <a href="./value_category.htm" title="c/language/value category">modifiable lvalues</a>, and although their address may be taken, they cannot appear on the left hand side of an assignment operator. However, structs with array members are modifiable lvalues and can be assigned:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span><span class="br0">}</span>, b<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">6</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>a<span class="sy4">;</span> <span class="co1">// okay, address of a can be taken</span>
<span class="co1">// a = b;            // error, a is an array</span>
<span class="kw1">struct</span> <span class="br0">{</span> <span class="kw4">int</span> c<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy4">;</span> <span class="br0">}</span> s1, s2 <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">3</span>,<span class="nu0">4</span>,<span class="nu0">5</span><span class="br0">}</span><span class="sy4">;</span>
s1 <span class="sy1">=</span> s2<span class="sy4">;</span> <span class="co1">// okay: can assign structs holding array members</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=8" title="Edit section: Array to pointer conversion">edit</a>]</span> <span class="mw-headline" id="Array_to_pointer_conversion">Array to pointer conversion</span></h4>
<p>Any <a href="./value_category.htm" title="c/language/value category">lvalue expression</a> of array type, when used in any context other than
</p>
<ul><li> as the operand of the <a href="./operator_member_access.htm" title="c/language/operator member access">address-of operator</a>
</li><li> as the operand of <a href="./sizeof.htm" title="c/language/sizeof"><code>sizeof</code></a>
</li><li> as the operand of <a href="./typeof_unqual.htm" title="c/language/typeof"><code>typeof</code></a> and <a href="./typeof_unqual.htm" title="c/language/typeof unqual" class="mw-redirect"><code>typeof_unqual</code></a> <span class="t-mark-rev t-since-c23">(since C23)</span>
</li><li> as the string literal used for <a href="./array_initialization.htm" title="c/language/array initialization">array initialization</a>
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-c11"><td>
<ul><li> as the operand of <span class="t-rev-inl t-since-c11 t-until-c23"><span><a href="./alignof.htm" title="c/language/ Alignof"><code>_Alignof</code></a></span><span><span class="t-mark-rev t-since-c11">(since C11)</span><span class="t-mark-rev t-until-c23">(until C23)</span></span></span><span class="t-rev-inl t-since-c23"><span><a href="./alignof.htm" title="c/language/alignof" class="mw-redirect"><code>alignof</code></a></span><span><span class="t-mark-rev t-since-c23">(since C23)</span></span></span>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-c11">(since C11)</span></td></tr>
</tbody></table>
<p>undergoes an <a href="./conversion.htm" title="c/language/conversion">implicit conversion</a> to the pointer to its first element. The result is not an lvalue.
</p><p>If the array was declared <a href="./storage_class_specifiers.htm" title="c/language/storage duration"><code>register</code></a>, the behavior of the program that attempts such conversion is undefined.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> a<span class="sy4">;</span>
<a href="../io/fprintf.htm"><span class="kw851">printf</span></a><span class="br0">(</span><span class="st0">"%zu<span class="es1">\n</span>"</span>, <span class="kw4">sizeof</span> a<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints size of array</span>
<a href="../io/fprintf.htm"><span class="kw851">printf</span></a><span class="br0">(</span><span class="st0">"%zu<span class="es1">\n</span>"</span>, <span class="kw4">sizeof</span> p<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints size of a pointer</span></pre></div></div>
<p>When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span> a<span class="br0">)</span></span></span> declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> sz<span class="br0">)</span> <span class="co1">// actually declares void f(int* a, int sz)</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> sz<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
        <a href="../io/fprintf.htm"><span class="kw851">printf</span></a><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span>, a<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>a<span class="br0">)</span><span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="br0">)</span> <span class="co1">// pointer to array parameter is not transformed</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
        <a href="../io/fprintf.htm"><span class="kw851">printf</span></a><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span>, <span class="br0">(</span><span class="sy2">*</span>a<span class="br0">)</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
    f<span class="br0">(</span>a, <span class="nu0">10</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// converts a to int*, passes the pointer</span>
    g<span class="br0">(</span><span class="sy3">&amp;</span>a<span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// passes a pointer to the array (no need to pass the size)</span>
<span class="br0">}</span></pre></div></div>
</div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=9" title="Edit section: Multidimensional arrays">edit</a>]</span> <span class="mw-headline" id="Multidimensional_arrays">Multidimensional arrays</span></h4>
<p>When the element type of an array is another array, it is said that the array is multidimensional:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="co1">// array of 2 arrays of 3 ints each</span>
<span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span><span class="br0">}</span>,  <span class="co1">// can be viewed as a 2x3 matrix</span>
               <span class="br0">{</span><span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">6</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// with row-major layout</span></pre></div></div>
<p>Note that when array-to-pointer conversion is applied, a multidimensional array is converted to a pointer to its first element, e.g., pointer to the first row:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// 2x3 matrix</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p1<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> a<span class="sy4">;</span> <span class="co1">// pointer to the first 3-element row</span>
<span class="kw4">int</span> b<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// 3x3x3 cube</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p2<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> b<span class="sy4">;</span> <span class="co1">// pointer to the first 3x3 plane</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-c99"><td>
<p>Multidimensional arrays may be variably modified in every dimension<span class="t-rev-inl t-since-c11"><span> if VLAs are supported</span><span><span class="t-mark-rev t-since-c11">(since C11)</span></span></span>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>
<span class="kw4">int</span> a<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span><span class="nu0">2</span><span class="sy2">*</span>n<span class="br0">]</span><span class="sy4">;</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-c99">(since C99)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=10" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<p>Zero-length array declarations are not allowed, even though some compilers offer them as extensions (typically as a pre-C99 implementation of <a href="./struct.htm" title="c/language/struct">flexible array members</a>).
</p><p>If the size <span class="t-spar">expression</span> of a VLA has side effects, they are guaranteed to be produced except when it is a part of a sizeof expression whose result doesn't depend on it:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">5</span>, m <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
<a href="../types/size_t.htm"><span class="kw100">size_t</span></a> sz <span class="sy1">=</span> <span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">[</span>n<span class="sy2">++</span><span class="br0">]</span><span class="br0">)</span><span class="br0">[</span>m<span class="sy2">++</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// n is incremented, m may or may not be incremented</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=11" title="Edit section: References">edit</a>]</span> <span class="mw-headline" id="References">References</span></h3>
<div class="t-ref-std-23">
<ul><li> C23 standard (ISO/IEC 9899:2024): 
</li></ul>
<dl><dd><ul><li> 6.7.6.2 Array declarators (p: TBD)
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-17">
<ul><li> C17 standard (ISO/IEC 9899:2018): 
</li></ul>
<dl><dd><ul><li> 6.7.6.2 Array declarators (p: 94-96)
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-11">
<ul><li> C11 standard (ISO/IEC 9899:2011): 
</li></ul>
<dl><dd><ul><li> 6.7.6.2 Array declarators (p: 130-132)
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c99">
<ul><li> C99 standard (ISO/IEC 9899:1999): 
</li></ul>
<dl><dd><ul><li> 6.7.5.2 Array declarators (p: 116-118)
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c89">
<ul><li> C89/C90 standard (ISO/IEC 9899:1990): 
</li></ul>
<dl><dd><ul><li> 3.5.4.2 Array declarators 
</li></ul>
</dd></dl>
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;action=edit&amp;section=12" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see"><span><a href="https://en.cppreference.com/w/cpp/language/array.html" title="cpp/language/array">C++ documentation</a></span> for <span class=""><span>Array declaration</span></span></div>
</td></tr>

</tbody></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 3797/1000000
Preprocessor generated node count: 9166/1000000
Post‐expand include size: 71860/4194304 bytes
Template argument size: 24105/4194304 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:13930-0!*!0!!en!*!* and timestamp 20250418073854 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;oldid=179987">https://en.cppreference.com/mwiki/index.php?title=c/language/array&amp;oldid=179987</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        



<!-- Served in 1.111 secs. -->
	


</body><!-- Cached 20250418073854 --></html>